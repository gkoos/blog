<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Go Interfaces - Composition Over Inheritance (And Common Sense)</title>
  <meta name="description" content="A post about golanfg interfaces">

  <!-- Facebook Meta Tags -->
  <meta property="og:url" content="https://gaborkoos.com">
  <meta property="og:type" content="website">
  <meta property="og:title" content="Go Interfaces - Composition Over Inheritance (And Common Sense)">
  <meta property="og:description" content="A post about golanfg interfaces">
  <meta property="og:image" content="https://opengraph.b-cdn.net/production/images/74740c4e-d40d-49be-83fb-7170084dbda1.png?token=3Pxj4Ccc7Z93zXgN6-HhJM8U3lpcnqtTs8xNIPoUzF4&height=614&width=620&expires=33290472379">

  <!-- Twitter Meta Tags -->
  <meta name="twitter:card" content="summary_large_image">
  <meta property="twitter:domain" content="gaborkoos.com">
  <meta property="twitter:url" content="https://gaborkoos.com">
  <meta name="twitter:title" content="Go Interfaces - Composition Over Inheritance (And Common Sense)">
  <meta name="twitter:description" content="A post about golanfg interfaces">
  <meta name="twitter:image" content="https://opengraph.b-cdn.net/production/images/74740c4e-d40d-49be-83fb-7170084dbda1.png?token=3Pxj4Ccc7Z93zXgN6-HhJM8U3lpcnqtTs8xNIPoUzF4&height=614&width=620&expires=33290472379">

  <!-- Meta Tags Generated via https://www.opengraph.xyz -->

  <!-- Analytics -->
  <script data-goatcounter="https://gkoos.goatcounter.com/count"  async src="//gc.zgo.at/count.js"></script>

  
  
  


  <link rel="icon" type="image/x-icon" href="/assets/images/favicon.ico" />
  <link rel="stylesheet" href="/assets/css/styles.css" />
  <link rel="stylesheet" href="/assets/css/vendor/prism-tomorrow.css" />
  <link rel="stylesheet" href="/assets/css/fix-inline-code.css" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
</head>
<body class="bg-white dark:bg-gray-900 text-gray-900 dark:text-gray-100 font-['Inter',system-ui,sans-serif] antialiased leading-relaxed">
  <!-- Header/Navigation with Theme Switcher -->
  <header class="border-b border-gray-100 bg-white dark:bg-gray-900 text-gray-900 dark:text-gray-100 sticky top-0 z-10 transition-colors">
    <div class="max-w-4xl mx-auto px-6 py-6">
      <nav class="flex items-center justify-between">
        <div>
          <a href="/" class="text-base sm:text-xl font-semibold text-gray-900 dark:text-white hover:text-gray-700 dark:hover:text-gray-300 transition-colors mr-4 sm:mr-0">
            a developer blog
          </a>
        </div>
        <div class="flex items-center space-x-6">
          <a href="/" class="text-sm text-gray-600 dark:text-gray-300 hover:text-gray-900 dark:hover:text-white transition-colors">Home</a>
          <a href="https://gaborkoos.com" class="text-sm text-gray-600 dark:text-gray-300 hover:text-gray-900 dark:hover:text-white transition-colors">About</a>
          <a href="/publications" class="text-sm text-gray-600 dark:text-gray-300 hover:text-gray-900 dark:hover:text-white transition-colors">Publications</a>
          <a href="/categories" class="text-sm text-gray-600 dark:text-gray-300 hover:text-gray-900 dark:hover:text-white transition-colors">Categories</a>
          <a href="/feed.xml" class="text-sm text-gray-600 dark:text-gray-300 hover:text-gray-900 dark:hover:text-white transition-colors">RSS</a>
          <!-- Theme Switcher Button -->
          <button id="theme-toggle" aria-label="Toggle dark mode" class="ml-4 p-2 rounded focus:outline-none bg-white dark:bg-gray-900 text-gray-700 dark:text-gray-200 transition-colors" style="display:inline-block;">
            <span id="theme-toggle-light" style="display:none">ðŸŒž</span>
            <span id="theme-toggle-dark" style="display:none">ðŸŒ™</span>
          </button>
        </div>
      </nav>
    </div>
  </header>


  <main class="max-w-4xl mx-auto px-6 py-12 transition-colors">
  <div class="prose prose-lg prose-gray dark:prose-invert max-w-none">
    
<article>
  <h1 class="text-3xl font-bold mb-4">Go Interfaces - Composition Over Inheritance (And Common Sense)</h1>
  <div class="flex items-center space-x-4 text-sm text-gray-500 mb-6">
    <time datetime="2025-08-10T00:00:00.000Z">Sun Aug 10 2025</time>
    
    
      <span class="text-gray-300">â€¢</span>
      <div class="flex flex-wrap gap-2">
        
          <div class="flex items-center rounded-full bg-teal-500 text-white dark:bg-teal-400/10 dark:text-teal-300 px-3 py-1 text-xs font-medium leading-5">tutorial</div>
        
          <div class="flex items-center rounded-full bg-teal-500 text-white dark:bg-teal-400/10 dark:text-teal-300 px-3 py-1 text-xs font-medium leading-5">golang</div>
        
      </div>
    
  </div>
  <div class="prose dark:prose-invert max-w-none">
    <p>Coming from a language like C# or JavaScript, interfaces in Go can feel like a cruel joke. Theyâ€™re not what you expect, and they donâ€™t play by the rules youâ€™re used to. This post is your survival guide to Go interfaces.</p>
<h2 id="interfaces---the-old-way" tabindex="-1"><a class="header-anchor" href="#interfaces---the-old-way">Interfaces - The Old Way</a></h2>
<p>In more traditional languages, interfaces are binding contracts: you define methods in an interface, and a class in order to satisfy that interface must implement those methods. In exchange, at any point in your code where you expect that interface, you can pass any class that implements it.</p>
<p>Let's see a quick example. We want to log messages, but at this point we're not sure where. Maybe to a file, maybe to the console, maybe to a remote server. All we know is we want to log messages, warnings, and errors. So we define a Logger interface:</p>
<pre class="language-csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ILogger</span>
<span class="token punctuation">{</span>
  <span class="token keyword">void</span> <span class="token function">Log</span><span class="token punctuation">(</span>string message<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">void</span> <span class="token function">Warn</span><span class="token punctuation">(</span>string message<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">void</span> <span class="token function">Error</span><span class="token punctuation">(</span>string message<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>We don't care what happens when we call these methods, but we know we will need them. At this point we just get on with our code and use these methods as if they were real:</p>
<pre class="language-csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OrderProcessor</span>
<span class="token punctuation">{</span>
  <span class="token keyword">private</span> readonly ILogger _logger<span class="token punctuation">;</span>

  <span class="token keyword">public</span> <span class="token function">OrderProcessor</span><span class="token punctuation">(</span><span class="token parameter">ILogger logger</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    _logger <span class="token operator">=</span> logger<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">ProcessOrder</span><span class="token punctuation">(</span><span class="token parameter">string orderId</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    _logger<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span>$<span class="token string">"Processing order {orderId}..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token keyword">if</span> <span class="token punctuation">(</span>string<span class="token punctuation">.</span><span class="token function">IsNullOrEmpty</span><span class="token punctuation">(</span>orderId<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
      _logger<span class="token punctuation">.</span><span class="token function">Warn</span><span class="token punctuation">(</span><span class="token string">"Order ID is empty."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">ChargePayment</span><span class="token punctuation">(</span>orderId<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
      _logger<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span>$<span class="token string">"Failed to charge payment for order {orderId}."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span>
    <span class="token punctuation">{</span>
      _logger<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span>$<span class="token string">"Order {orderId} processed successfully."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>So we do things, and from time to time we call methods on the Logger. Maybe while developing we log to the console, but later we want to log to a file. So we create a ScreenLogger and a Filelogger class that implement the ILogger interface:</p>
<pre class="language-csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ScreenLogger</span> <span class="token operator">:</span> ILogger
<span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">Log</span><span class="token punctuation">(</span><span class="token parameter">string message</span><span class="token punctuation">)</span> <span class="token operator">=></span> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>$<span class="token string">"[LOG] {message}"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">Warn</span><span class="token punctuation">(</span><span class="token parameter">string message</span><span class="token punctuation">)</span> <span class="token operator">=></span> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>$<span class="token string">"[WARN] {message}"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">Error</span><span class="token punctuation">(</span><span class="token parameter">string message</span><span class="token punctuation">)</span> <span class="token operator">=></span> Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>$<span class="token string">"[ERROR] {message}"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FileLogger</span> <span class="token operator">:</span> ILogger
<span class="token punctuation">{</span>
  <span class="token keyword">private</span> readonly string _filePath<span class="token punctuation">;</span>

  <span class="token keyword">public</span> <span class="token function">FileLogger</span><span class="token punctuation">(</span><span class="token parameter">string filePath</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    _filePath <span class="token operator">=</span> filePath<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">Log</span><span class="token punctuation">(</span><span class="token parameter">string message</span><span class="token punctuation">)</span> <span class="token operator">=></span> File<span class="token punctuation">.</span><span class="token function">AppendAllText</span><span class="token punctuation">(</span>_filePath<span class="token punctuation">,</span> $<span class="token string">"[LOG] {message}\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">Warn</span><span class="token punctuation">(</span><span class="token parameter">string message</span><span class="token punctuation">)</span> <span class="token operator">=></span> File<span class="token punctuation">.</span><span class="token function">AppendAllText</span><span class="token punctuation">(</span>_filePath<span class="token punctuation">,</span> $<span class="token string">"[WARN] {message}\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">Error</span><span class="token punctuation">(</span><span class="token parameter">string message</span><span class="token punctuation">)</span> <span class="token operator">=></span> File<span class="token punctuation">.</span><span class="token function">AppendAllText</span><span class="token punctuation">(</span>_filePath<span class="token punctuation">,</span> $<span class="token string">"[ERROR] {message}\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Note that the <code>FileLogger</code> also has a constructor that takes a file path, which is not part of the <code>ILogger</code> interface. This is fine because, as long as the class implements the methods defined in the interface, it can have any additional methods or properties it needs.</p>
<p>This way, we can pass either a <code>ScreenLogger</code> or a <code>FileLogger</code> to the <code>OrderProcessor</code>, and it will work seamlessly:</p>
<pre class="language-csharp"><code class="language-csharp"><span class="token keyword">var</span> <span class="token literal-property property">logger</span><span class="token operator">:</span> ILogger<span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>production<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  logger <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileLogger</span><span class="token punctuation">(</span><span class="token string">"logs.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">else</span>
<span class="token punctuation">{</span>
  logger <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ScreenLogger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> processor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">OrderProcessor</span><span class="token punctuation">(</span>logger<span class="token punctuation">)</span><span class="token punctuation">;</span>
processor<span class="token punctuation">.</span><span class="token function">ProcessOrder</span><span class="token punctuation">(</span><span class="token string">"12345"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>Because both classes implement the <code>ILogger</code> interface, we can use them interchangeably. This is the essence of interfaces in traditional languages: they define a contract that classes must adhere to, allowing for polymorphism and flexibility.</p>
<h2 id="interfaces-in-go" tabindex="-1"><a class="header-anchor" href="#interfaces-in-go">Interfaces in Go</a></h2>
<p>In Go, interfaces are a bit different. Theyâ€™re not explicit contracts that you implement; theyâ€™re more like a set of expectations that your types can fulfill without any formal declaration. This can be both liberating and confusing. The previous example would look like this in Go:</p>
<pre class="language-go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">"fmt"</span>
	<span class="token string">"os"</span>
<span class="token punctuation">)</span>

<span class="token comment">// 1. Logger interface definition</span>
type Logger <span class="token keyword">interface</span> <span class="token punctuation">{</span>
	<span class="token function">Log</span><span class="token punctuation">(</span>message string<span class="token punctuation">)</span>
	<span class="token function">Warn</span><span class="token punctuation">(</span>message string<span class="token punctuation">)</span>
	<span class="token function">Error</span><span class="token punctuation">(</span>message string<span class="token punctuation">)</span>
<span class="token punctuation">}</span>


<span class="token comment">// 2. ScreenLogger implementation:</span>
type ScreenLogger struct<span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token function">func</span> <span class="token punctuation">(</span>ScreenLogger<span class="token punctuation">)</span> <span class="token function">Log</span><span class="token punctuation">(</span><span class="token parameter">message string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"[LOG] %s\n"</span><span class="token punctuation">,</span> message<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token function">func</span> <span class="token punctuation">(</span>ScreenLogger<span class="token punctuation">)</span> <span class="token function">Warn</span><span class="token punctuation">(</span><span class="token parameter">message string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"[WARN] %s\n"</span><span class="token punctuation">,</span> message<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token function">func</span> <span class="token punctuation">(</span>ScreenLogger<span class="token punctuation">)</span> <span class="token function">Error</span><span class="token punctuation">(</span><span class="token parameter">message string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"[ERROR] %s\n"</span><span class="token punctuation">,</span> message<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">// At this point ScreenLogger has Log, Warn, and Error methods.</span>
<span class="token comment">// This means it satisfies the Logger interface!</span>


<span class="token comment">// 3. FileLogger implementation:</span>
type FileLogger struct <span class="token punctuation">{</span>
	filePath string
<span class="token punctuation">}</span>

<span class="token comment">// Creates a new FileLogger instance with the specified file path.</span>
<span class="token comment">// This is similar to the constructor in C#.</span>
func <span class="token function">NewFileLogger</span><span class="token punctuation">(</span>path string<span class="token punctuation">)</span> <span class="token operator">*</span>FileLogger <span class="token punctuation">{</span>
	<span class="token keyword">return</span> <span class="token operator">&amp;</span>FileLogger<span class="token punctuation">{</span><span class="token literal-property property">filePath</span><span class="token operator">:</span> path<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// Helper method to append messages to a file.</span>
<span class="token comment">// Not part of the Logger interface, but FileLogger needs it.</span>
<span class="token comment">// It starts with lowercase so it's also private to this package.</span>
<span class="token function">func</span> <span class="token punctuation">(</span>f <span class="token operator">*</span>FileLogger<span class="token punctuation">)</span> <span class="token function">appendToFile</span><span class="token punctuation">(</span><span class="token parameter">prefix<span class="token punctuation">,</span> message string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	file<span class="token punctuation">,</span> <span class="token literal-property property">err</span> <span class="token operator">:</span><span class="token operator">=</span> os<span class="token punctuation">.</span><span class="token function">OpenFile</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span>filePath<span class="token punctuation">,</span> os<span class="token punctuation">.</span><span class="token constant">O_APPEND</span><span class="token operator">|</span>os<span class="token punctuation">.</span><span class="token constant">O_CREATE</span><span class="token operator">|</span>os<span class="token punctuation">.</span><span class="token constant">O_WRONLY</span><span class="token punctuation">,</span> <span class="token number">0644</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> nil <span class="token punctuation">{</span>
		fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"Error opening log file: %v\n"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
		<span class="token keyword">return</span>
	<span class="token punctuation">}</span>
	defer file<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span> <span class="token string">"%s %s\n"</span><span class="token punctuation">,</span> prefix<span class="token punctuation">,</span> message<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token function">func</span> <span class="token punctuation">(</span>f <span class="token operator">*</span>FileLogger<span class="token punctuation">)</span> <span class="token function">Log</span><span class="token punctuation">(</span><span class="token parameter">message string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	f<span class="token punctuation">.</span><span class="token function">appendToFile</span><span class="token punctuation">(</span><span class="token string">"[LOG]"</span><span class="token punctuation">,</span> message<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token function">func</span> <span class="token punctuation">(</span>f <span class="token operator">*</span>FileLogger<span class="token punctuation">)</span> <span class="token function">Warn</span><span class="token punctuation">(</span><span class="token parameter">message string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	f<span class="token punctuation">.</span><span class="token function">appendToFile</span><span class="token punctuation">(</span><span class="token string">"[WARN]"</span><span class="token punctuation">,</span> message<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token function">func</span> <span class="token punctuation">(</span>f <span class="token operator">*</span>FileLogger<span class="token punctuation">)</span> <span class="token function">Error</span><span class="token punctuation">(</span><span class="token parameter">message string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	f<span class="token punctuation">.</span><span class="token function">appendToFile</span><span class="token punctuation">(</span><span class="token string">"[ERROR]"</span><span class="token punctuation">,</span> message<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">// At this point FileLogger also has Log, Warn, and Error methods.</span>
<span class="token comment">// This means it satisfies the Logger interface too!</span>


<span class="token comment">// Business logic that depends on Logger</span>
func <span class="token function">ProcessOrder</span><span class="token punctuation">(</span><span class="token parameter">orderID string<span class="token punctuation">,</span> logger Logger</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	logger<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"Processing order "</span> <span class="token operator">+</span> orderID <span class="token operator">+</span> <span class="token string">"..."</span><span class="token punctuation">)</span>

	<span class="token keyword">if</span> orderID <span class="token operator">==</span> <span class="token string">""</span> <span class="token punctuation">{</span>
		logger<span class="token punctuation">.</span><span class="token function">Warn</span><span class="token punctuation">(</span><span class="token string">"Order ID is empty."</span><span class="token punctuation">)</span>
		<span class="token keyword">return</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">if</span> orderID<span class="token punctuation">[</span><span class="token function">len</span><span class="token punctuation">(</span>orderID<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'0'</span> <span class="token punctuation">{</span>
		logger<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token string">"Failed to charge payment for order "</span> <span class="token operator">+</span> orderID<span class="token punctuation">)</span>
	<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
		logger<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"Order "</span> <span class="token operator">+</span> orderID <span class="token operator">+</span> <span class="token string">" processed successfully."</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

func <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">var</span> logger Logger
	<span class="token keyword">if</span> <span class="token literal-property property">production</span> <span class="token operator">:</span><span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> production <span class="token punctuation">{</span>
		logger <span class="token operator">=</span> <span class="token operator">&amp;</span>FileLogger<span class="token punctuation">{</span><span class="token string">"logs.txt"</span><span class="token punctuation">}</span>
	<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
		logger <span class="token operator">=</span> ScreenLogger<span class="token punctuation">{</span><span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

  <span class="token function">ProcessOrder</span><span class="token punctuation">(</span><span class="token string">"12345"</span><span class="token punctuation">,</span> logger<span class="token punctuation">)</span>
</code></pre>
<p>This Go code does the same thing as the C# example, but notice how we don't have to explicitly declare that <code>ScreenLogger</code> and <code>FileLogger</code> implement the <code>Logger</code> interface. They just do, and Go's compiler checks that they have the required methods.</p>
<p>This is called <strong>implicit implementation</strong>. If a type has the methods that an interface requires, it satisfies that interface. No need for a keyword like <code>implements</code> or <code>extends</code>. It's called <strong>duck typing</strong> in some circles, where the type is determined by its behavior rather than its explicit declaration. It's like Go is saying, &quot;If it walks like a duck and quacks like a duck, it's a duck&quot;.</p>
<p>So the key difference in philosophy is:</p>
<ul>
<li><em>Nominal Typing</em> (C#): &quot;You are a Logger if you say you are (and the compiler agrees).&quot;</li>
<li><em>Duck Typing</em> (Go): &quot;You are a Logger if you walk and quack like one, you don't have to say anything.&quot;</li>
</ul>
<h2 id="how-interfaces-are-actually-used-in-go" tabindex="-1"><a class="header-anchor" href="#how-interfaces-are-actually-used-in-go">How Interfaces Are Actually Used In Go</a></h2>
<p>In Go, interfaces are used extensively, often in ways that might feel odd. Here are some common patterns and practices:</p>
<h3 id="the-io.writer-and-io.reader-pattern" tabindex="-1"><a class="header-anchor" href="#the-io.writer-and-io.reader-pattern">The <code>io.Writer</code> and <code>io.Reader</code> Pattern</a></h3>
<p>The <code>io.Writer</code> and <code>io.Reader</code> interfaces are foundational in Go. They allow you to write data to various destinations (like files, network connections, or buffers) without caring about the underlying implementation. For example:</p>
<pre class="language-go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">"fmt"</span>
	<span class="token string">"io"</span>
	<span class="token string">"os"</span>
	<span class="token string">"strings"</span>
<span class="token punctuation">)</span>

func <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">var</span> w io<span class="token punctuation">.</span>Writer <span class="token comment">// io.Writer is a Go interface with one method: Write(p []byte) (n int, err error)</span>
	w <span class="token operator">=</span> os<span class="token punctuation">.</span>Stdout  <span class="token comment">// os.Stdout is a variable of type *os.File</span>
	<span class="token comment">// *os.File has a Write([]byte) (int, error) method, so it implicitly satisfies io.Writer</span>
	fmt<span class="token punctuation">.</span><span class="token function">Fprintln</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> <span class="token string">"Hello, World!"</span><span class="token punctuation">)</span> <span class="token comment">// Since w is os.Stdout, the text goes to your terminal</span>

	<span class="token keyword">var</span> r io<span class="token punctuation">.</span>Reader <span class="token comment">// io.Reader is a Go interface with one method: Read(p []byte) (n int, err error)</span>
	r <span class="token operator">=</span> strings<span class="token punctuation">.</span><span class="token function">NewReader</span><span class="token punctuation">(</span><span class="token string">"Hello, Reader!"</span><span class="token punctuation">)</span> <span class="token comment">// strings.NewReader returns a *strings.Reader, which has a Read([]byte) (int, error) method</span>
	io<span class="token punctuation">.</span><span class="token function">Copy</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>Stdout<span class="token punctuation">,</span> r<span class="token punctuation">)</span> <span class="token comment">// io.Copy(dst Writer, src Reader) reads from src and writes to dst until EOF or error</span>
<span class="token punctuation">}</span>
</code></pre>
<p>So, because any type with the right method set fits the interface, functions like <code>io.Copy</code> can work on any readable/writable thing â€” files, network sockets, buffers, etc. - without them being in the same inheritance tree.</p>
<p><em>And that's the key point here: this approach basically renders inheritance useless. You don't need a class hierarchy to achieve polymorphism; you just need types that implement the right methods.</em></p>
<h3 id="composition-via-embedding-interfaces" tabindex="-1"><a class="header-anchor" href="#composition-via-embedding-interfaces">Composition via Embedding Interfaces</a></h3>
<p>In Go, interfaces can be composed from other interfaces by simply listing them inside another interface. This is called embedding.</p>
<p>The new interface inherits all the methods of the embedded interfaces. It's like building larger interfaces out of smaller, focused ones.</p>
<pre class="language-go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token string">"fmt"</span>

<span class="token comment">// Two small, focused interfaces</span>
type Reader <span class="token keyword">interface</span> <span class="token punctuation">{</span>
	<span class="token function">Read</span><span class="token punctuation">(</span>p <span class="token punctuation">[</span><span class="token punctuation">]</span>byte<span class="token punctuation">)</span> <span class="token punctuation">(</span>n int<span class="token punctuation">,</span> err error<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

type Writer <span class="token keyword">interface</span> <span class="token punctuation">{</span>
	<span class="token function">Write</span><span class="token punctuation">(</span>p <span class="token punctuation">[</span><span class="token punctuation">]</span>byte<span class="token punctuation">)</span> <span class="token punctuation">(</span>n int<span class="token punctuation">,</span> err error<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// New interface composed from the two</span>
type ReadWriter <span class="token keyword">interface</span> <span class="token punctuation">{</span>
	Reader
	Writer
<span class="token punctuation">}</span>

<span class="token comment">// A type that implements both Read and Write automatically implements ReadWriter</span>
type MyBuffer struct <span class="token punctuation">{</span>
	data <span class="token punctuation">[</span><span class="token punctuation">]</span>byte
<span class="token punctuation">}</span>

<span class="token function">func</span> <span class="token punctuation">(</span>b <span class="token operator">*</span>MyBuffer<span class="token punctuation">)</span> <span class="token function">Read</span><span class="token punctuation">(</span>p <span class="token punctuation">[</span><span class="token punctuation">]</span>byte<span class="token punctuation">)</span> <span class="token punctuation">(</span>int<span class="token punctuation">,</span> error<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token literal-property property">n</span> <span class="token operator">:</span><span class="token operator">=</span> <span class="token function">copy</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> b<span class="token punctuation">.</span>data<span class="token punctuation">)</span>
	<span class="token keyword">return</span> n<span class="token punctuation">,</span> nil
<span class="token punctuation">}</span>

<span class="token function">func</span> <span class="token punctuation">(</span>b <span class="token operator">*</span>MyBuffer<span class="token punctuation">)</span> <span class="token function">Write</span><span class="token punctuation">(</span>p <span class="token punctuation">[</span><span class="token punctuation">]</span>byte<span class="token punctuation">)</span> <span class="token punctuation">(</span>int<span class="token punctuation">,</span> error<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	b<span class="token punctuation">.</span>data <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>data<span class="token punctuation">,</span> p<span class="token operator">...</span><span class="token punctuation">)</span>
	<span class="token keyword">return</span> <span class="token function">len</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">,</span> nil
<span class="token punctuation">}</span>

func <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">var</span> rw ReadWriter <span class="token operator">=</span> <span class="token operator">&amp;</span>MyBuffer<span class="token punctuation">{</span><span class="token punctuation">}</span>
	rw<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token literal-property property">buf</span> <span class="token operator">:</span><span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span>byte<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span>
	rw<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">string</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
<p>So you can break functionality into small interfaces (<code>Reader</code>, <code>Writer</code>), then combine them into richer ones (<code>ReadWriter</code>), with <em>composition</em>, not <em>inheritance</em>. This is a powerful way to build flexible and reusable components, without the rigidity of class hierarchies.</p>
<h3 id="interfaces-with-one-method" tabindex="-1"><a class="header-anchor" href="#interfaces-with-one-method">Interfaces with One Method</a></h3>
<p>This is a common pattern in Go. Many interfaces only have one method, which makes them easy to implement and use. Single-method interfaces are like Lego bricks - small, easy to snap together, and infinitely reusable.</p>
<p>One use case is when we add behavior to existing types without modifying them. For example, the <code>fmt.Stringer</code> interface:</p>
<pre class="language-go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">"fmt"</span>
<span class="token punctuation">)</span>

<span class="token comment">// From fmt package:</span>
<span class="token comment">// type Stringer interface {</span>
<span class="token comment">//     String() string</span>
<span class="token comment">// }</span>

<span class="token comment">// Define a new named type based on int</span>
type MyInt int

<span class="token comment">// Add the method required by Stringer</span>
<span class="token function">func</span> <span class="token punctuation">(</span>m MyInt<span class="token punctuation">)</span> <span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span> string <span class="token punctuation">{</span>
	<span class="token keyword">return</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"MyInt value: %d"</span><span class="token punctuation">,</span> m<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

func <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">var</span> s fmt<span class="token punctuation">.</span>Stringer

	<span class="token comment">// Works because MyInt has a String() method, therefore it satisfies fmt.Stringer</span>
	s <span class="token operator">=</span> <span class="token function">MyInt</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token comment">// Prints: MyInt value: 42</span>
<span class="token punctuation">}</span>
</code></pre>
<p>The key points here:</p>
<ol>
<li>We didn't touch <code>fmt.Stringer</code> (it's in the standard library).</li>
<li>We didn't modify <code>int</code> - we just defined our own <code>MyInt</code> type based on <code>int</code>.</li>
<li>By adding a single method, <code>MyInt</code> now satisfies <code>fmt.Stringer</code>.</li>
<li>Any function expecting a <code>fmt.Stringer</code> can now accept <code>MyInt</code>.</li>
</ol>
<p>One of the benefits of this approach is <code>loose coupling</code>. With inheritance the child class implements <em>all</em> methods of the parent class, which means if anything changes in the parent, it can break the child. In Go, you start with zero dependencies and only add what you need.</p>
<h3 id="the-interface%7B%7D-(empty-interface)-hell" tabindex="-1"><a class="header-anchor" href="#the-interface%7B%7D-(empty-interface)-hell">The <code>interface{}</code> (Empty Interface) Hell</a></h3>
<p><code>interface{}</code> is Goâ€™s empty interface â€” an interface with zero methods. It matches any type because every type implements zero or more methods, so every type satisfies an empty interface. It's like <code>Object</code> in Java or <code>any</code> in TypeScript.</p>
<p>So you can do this:</p>
<pre class="language-go"><code class="language-go"><span class="token keyword">var</span> x <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
x <span class="token operator">=</span> <span class="token number">42</span>              <span class="token comment">// int</span>
x <span class="token operator">=</span> <span class="token string">"hello"</span>         <span class="token comment">// string</span>
x <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>int<span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span>  <span class="token comment">// slice of int</span>
</code></pre>
<p>Before Go had generics, <code>interface{}</code> was often used to write functions or containersthat could accept any type. But it's easy to see how this can be misused. You lose type safety, break compile-time type safety, pushing errors to runtime. You have to use frequent type assertions or type switches to work with the value, which clutters your code and makes it harder to read.</p>
<p>This is often referred to as <em>interface{} hell</em>. You end up with code that looks like this:</p>
<pre class="language-go"><code class="language-go">func <span class="token function">PrintAnything</span><span class="token punctuation">(</span><span class="token parameter">v <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">switch</span> <span class="token literal-property property">v</span> <span class="token operator">:</span><span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">case</span> <span class="token literal-property property">int</span><span class="token operator">:</span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"int:"</span><span class="token punctuation">,</span> v<span class="token punctuation">)</span>
	<span class="token keyword">case</span> <span class="token literal-property property">string</span><span class="token operator">:</span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"string:"</span><span class="token punctuation">,</span> v<span class="token punctuation">)</span>
	<span class="token keyword">case</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>int<span class="token operator">:</span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"[]int:"</span><span class="token punctuation">,</span> v<span class="token punctuation">)</span>
	<span class="token keyword">default</span><span class="token operator">:</span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"unknown type"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

func <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">PrintAnything</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span>
  <span class="token function">PrintAnything</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span>
  <span class="token function">PrintAnything</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span>int<span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
<p>So, if you must use <code>interface{}</code>, keep the use localized and minimal.</p>
<h2 id="the-bad-and-the-ugly" tabindex="-1"><a class="header-anchor" href="#the-bad-and-the-ugly">The Bad And The Ugly</a></h2>
<p>We saw how Go interfaces work and how they can give you flexibility and power. But they also come with their own set of quirks and frustrations. Here are some common pain points:</p>
<h3 id="no-explicit-%22implements%22" tabindex="-1"><a class="header-anchor" href="#no-explicit-%22implements%22">No Explicit &quot;Implements&quot;</a></h3>
<p>If you look at a Go type, you can't tell at a glance which interfaces it implements. You have to read the code and see if it has the right methods. This can make it hard to understand how types relate to each other. Your IDE won't help you find all the places where a type is used as an interface, and you can't easily search for implementations of an interface.</p>
<h3 id="no-easy-way-to-declare-optional-interface-methods" tabindex="-1"><a class="header-anchor" href="#no-easy-way-to-declare-optional-interface-methods">No easy way to declare optional interface methods</a></h3>
<p>In Go, interfaces are satisfied only if a type implements all the methods declared. There is no built-in support for optional methods â€” you canâ€™t say &quot;a type may implement method X, but itâ€™s not required.&quot;</p>
<p>This means that if you want to design an interface with optional behavior, you usually have to:</p>
<ul>
<li>Split the interface into multiple smaller interfaces.</li>
<li>Check at runtime whether the type implements the optional interface by doing a type assertion.</li>
</ul>
<p>For example:</p>
<pre class="language-go"><code class="language-go">type Logger <span class="token keyword">interface</span> <span class="token punctuation">{</span>
    <span class="token function">Log</span><span class="token punctuation">(</span>msg string<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

type WarnLogger <span class="token keyword">interface</span> <span class="token punctuation">{</span>
    Logger
    <span class="token function">Warn</span><span class="token punctuation">(</span>msg string<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

func <span class="token function">UseLogger</span><span class="token punctuation">(</span><span class="token parameter">l Logger</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    l<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"info"</span><span class="token punctuation">)</span>

    <span class="token keyword">if</span> wl<span class="token punctuation">,</span> <span class="token literal-property property">ok</span> <span class="token operator">:</span><span class="token operator">=</span> l<span class="token punctuation">.</span><span class="token punctuation">(</span>WarnLogger<span class="token punctuation">)</span><span class="token punctuation">;</span> ok <span class="token punctuation">{</span>
        wl<span class="token punctuation">.</span><span class="token function">Warn</span><span class="token punctuation">(</span><span class="token string">"warning"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Here, Warn() is optional â€” you check at runtime if the logger supports it. This pattern is verbose and repetitive in many places where optional behavior is desired.</p>
<h3 id="error-handling-and-delegation-can-be-repetitive" tabindex="-1"><a class="header-anchor" href="#error-handling-and-delegation-can-be-repetitive">Error handling and delegation can be repetitive</a></h3>
<p>When delegating calls to embedded interfaces or composed structs, you often write boilerplate code that:</p>
<ul>
<li>Checks errors.</li>
<li>Passes method calls through.</li>
<li>Wraps or annotates errors.</li>
</ul>
<p>Since Go doesn't have inheritance or automatic delegation like some OOP languages, you write this manually.</p>
<p>For example:</p>
<pre class="language-go"><code class="language-go">type MyWriter struct <span class="token punctuation">{</span>
    w io<span class="token punctuation">.</span>Writer
<span class="token punctuation">}</span>

<span class="token function">func</span> <span class="token punctuation">(</span>m <span class="token operator">*</span>MyWriter<span class="token punctuation">)</span> <span class="token function">Write</span><span class="token punctuation">(</span>p <span class="token punctuation">[</span><span class="token punctuation">]</span>byte<span class="token punctuation">)</span> <span class="token punctuation">(</span>int<span class="token punctuation">,</span> error<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    n<span class="token punctuation">,</span> <span class="token literal-property property">err</span> <span class="token operator">:</span><span class="token operator">=</span> m<span class="token punctuation">.</span>w<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span>
    <span class="token keyword">if</span> err <span class="token operator">!=</span> nil <span class="token punctuation">{</span>
        <span class="token keyword">return</span> n<span class="token punctuation">,</span> fmt<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"write failed: %w"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> n<span class="token punctuation">,</span> nil
<span class="token punctuation">}</span>
</code></pre>
<p>This small wrapper adds error wrapping, but the code has to be written for each method manually. For interfaces with many methods, this boilerplate quickly adds up.</p>
<h3 id="reflection-needed-for-some-dynamic-uses" tabindex="-1"><a class="header-anchor" href="#reflection-needed-for-some-dynamic-uses">Reflection Needed for Some Dynamic Uses</a></h3>
<p>In Go, if you want to inspect types at runtime or dynamically invoke methods, you often have to use the <code>reflect</code> package.</p>
<p>Example: imagine you want to write a generic function that prints all fields of any struct:</p>
<pre class="language-go"><code class="language-go">func <span class="token function">PrintFields</span><span class="token punctuation">(</span><span class="token parameter">v <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">val</span> <span class="token operator">:</span><span class="token operator">=</span> reflect<span class="token punctuation">.</span><span class="token function">ValueOf</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span>
    <span class="token literal-property property">typ</span> <span class="token operator">:</span><span class="token operator">=</span> val<span class="token punctuation">.</span><span class="token function">Type</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token keyword">if</span> val<span class="token punctuation">.</span><span class="token function">Kind</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> reflect<span class="token punctuation">.</span>Struct <span class="token punctuation">{</span>
        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Not a struct"</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">for</span> <span class="token literal-property property">i</span> <span class="token operator">:</span><span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> val<span class="token punctuation">.</span><span class="token function">NumField</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
        <span class="token literal-property property">field</span> <span class="token operator">:</span><span class="token operator">=</span> val<span class="token punctuation">.</span><span class="token function">Field</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
        fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%s = %v\n"</span><span class="token punctuation">,</span> typ<span class="token punctuation">.</span><span class="token function">Field</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span>Name<span class="token punctuation">,</span> field<span class="token punctuation">.</span><span class="token function">Interface</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>This is powerful, but it can also lead to code that is hard to understand and maintain. You lose the compile-time type safety that Go is known for, and you have to deal with the complexities of reflection: verbose and complex syntax, runtime errors if you get types or method names wrong and performance overhead compared to direct calls.</p>
<h3 id="interface-pollution" tabindex="-1"><a class="header-anchor" href="#interface-pollution">Interface Pollution</a></h3>
<p>In Go, it's common to see interfaces exported instead of structs. This can lead to interface pollution, where you end up with many small interfaces that are used everywhere, making it hard to track down where a type is used. This is especially true in large codebases or when using third-party libraries.</p>
<h2 id="how-to-work-with-it-(best-practices)" tabindex="-1"><a class="header-anchor" href="#how-to-work-with-it-(best-practices)">How to Work With It (Best Practices)</a></h2>
<p>To avoid the pitfalls of Go interfaces, here are some best practices:</p>
<ol>
<li><strong>Use Small Interfaces</strong>: Prefer small, focused interfaces over large, monolithic ones. This makes it easier to implement, understand and reuse. For example, use <code>io.Writer</code> instead of a big <code>BigAbstractThing</code> interface.</li>
<li><strong>Accept Interfaces, Return Structs</strong>: When designing functions, accept interfaces as parameters but return concrete types. This allows you to use the interface's flexibility while keeping the implementation details hidden.</li>
<li><strong>Make Interface Implementations Explicit</strong>: Use <code>var _ Interface = (*Type)(nil)</code> to make it explicit that a type implements an interface. This can help catch errors at compile time and improve code readability.</li>
<li><strong>Avoid <code>interface{}</code> Unless Necessary</strong>: Use the empty interface sparingly. If you find yourself using it often, consider whether you can define a more specific interface instead. Or use generics.</li>
<li><strong>Use Type Assertions Carefully</strong>: If you need to use type assertions, do so in a controlled manner. Prefer type switches over multiple assertions, and document the expected types clearly.</li>
<li><strong>Keep Interfaces Localized</strong>: If an interface is only used in one package, keep it there. Don't export it unless necessary. This reduces interface pollution and makes your code easier to navigate.</li>
</ol>
<p>Following these practices can help you write cleaner, more maintainable Go code that leverages the power of interfaces without falling into the common traps. It's still not as straightforward as in some other languages, but with a bit of common sense and experience, you can make it work for you. Good luck, you'll need it!</p>
<h2 id="closing-thoughts" tabindex="-1"><a class="header-anchor" href="#closing-thoughts">Closing Thoughts</a></h2>
<p>We saw how Go interfaces work from a technical perspective. But I think because they just feel so weird, the biggest challenge is the mindset shift. In Go, interfaces just happen, sometimes without you even realizing it. You write a type, and suddenly it satisfies an interface. Like seriously?</p>
<p>Sometimes it can be a good thing. Decoupling your code from specific implementations can lead to more flexible and reusable components. Mocking becomes a breeze, and you can swap out implementations without changing the code that uses them.</p>
<p>But it can also lead to confusion and frustration. You might find yourself wondering why your type doesn't satisfy an interface, or why the compiler isn't complaining when you think it should. The lack of explicit contracts can make it hard to understand how types relate to each other, and the implicit nature of interface satisfaction can lead to unexpected behavior.</p>
<p>Good thing is, you don't have to like it. Bad thing is, you have to understand them to use Go effectively. So embrace the weirdness, learn the patterns, and remember that Go interfaces are just another tool in your toolbox. They might not be what you're used to, but with a bit of practice, you will know how to tolerate them.</p>

  </div>
</article>

  </div>
  </main>

  <!-- Footer -->
  <footer class="border-t border-gray-100 bg-gray-50 dark:bg-gray-900 text-gray-900 dark:text-gray-100 mt-20 transition-colors">
    <div class="max-w-4xl mx-auto px-6 py-12">
      <div class="text-center text-sm text-gray-600 dark:text-gray-300">
        <p>&copy; <span id="footer-year"></span> Gabor Koos</p>
      </div>
    </div>
  </footer>
  <!-- Theme Switcher Script -->
  <script>
    // Footer year
    document.getElementById('footer-year').textContent = new Date().getFullYear();
    // Theme switcher logic
    const root = document.documentElement;
    const themeToggle = document.getElementById('theme-toggle');
    const lightIcon = document.getElementById('theme-toggle-light');
    const darkIcon = document.getElementById('theme-toggle-dark');
    function setTheme(mode) {
      if (mode === 'dark') {
        root.classList.add('dark');
        localStorage.setItem('theme', 'dark');
        darkIcon.style.display = 'none';
        lightIcon.style.display = '';
      } else {
        root.classList.remove('dark');
        localStorage.setItem('theme', 'light');
        darkIcon.style.display = '';
        lightIcon.style.display = 'none';
      }
    }
    // Initial theme
    const userTheme = localStorage.getItem('theme');
    const systemDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
    if (userTheme === 'dark' || (!userTheme && systemDark)) {
      setTheme('dark');
    } else {
      setTheme('light');
    }
    // Button is always visible; only icons are toggled
    themeToggle.addEventListener('click', () => {
    if (root.classList.contains('dark')) {
      setTheme('light');
    } else {
      setTheme('dark');
    }
    });
  </script>
</body>

<script>
document.addEventListener('DOMContentLoaded', function () {
  document.querySelectorAll('pre code').forEach(function (codeBlock) {
    var pre = codeBlock.parentNode;
    pre.style.position = 'relative';
    pre.style.overflow = 'auto';

    var button = document.createElement('button');
    button.className = 'copy-btn';
    button.type = 'button';
    button.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#333" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg>';
    button.style = 'position:absolute;top:0.2em;right:0.2em;padding:0.05em 0.05em;width:1.2em;height:1.2em;display:flex;align-items:center;justify-content:center;background:#eee;border-radius:0.2em;border:none;cursor:pointer;z-index:1;opacity:0.7;box-shadow:0 2px 8px rgba(0,0,0,0.08);transition:opacity 0.2s;pointer-events:auto;';
    button.onmouseenter = function() { button.style.opacity = '1'; };
    button.onmouseleave = function() { button.style.opacity = '0.7'; };
    pre.appendChild(button);
    button.addEventListener('click', function () {
      navigator.clipboard.writeText(codeBlock.innerText);
      var original = button.innerHTML;
      button.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#16a34a" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"/></svg>';
      setTimeout(function () {
        button.innerHTML = original;
      }, 1200);
    });
  });
});
</script>

</body>
</html>
